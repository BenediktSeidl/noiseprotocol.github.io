<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Trevor Perrin (noise@trevp.net)" />
  <meta name="date" content="2016-04-04" />
  <title>The Noise Protocol Framework</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="spec_markdown.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">The Noise Protocol Framework</h1>
<b>Author:</b> Trevor Perrin (noise@trevp.net)<br/>
<b>Revision:</b> 25<br/>
<b>Date:</b> 2016-04-04<br/>
</div>
<div id="TOC">
<h2 class="toc">Table of Contents</h2>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#overview">2. Overview</a><ul>
<li><a href="#terminology">2.1. Terminology</a></li>
<li><a href="#handshake-state-machine">2.2. Handshake state machine</a></li>
</ul></li>
<li><a href="#message-format">3. Message format</a></li>
<li><a href="#crypto-functions">4. Crypto functions</a></li>
<li><a href="#processing-rules-for-handshake-and-transport-messages">5. Processing rules for handshake and transport messages</a><ul>
<li><a href="#the-cipherstate-object">5.1 The <code>CipherState</code> object</a></li>
<li><a href="#the-symmetricstate-object">5.2. The <code>SymmetricState</code> object</a></li>
<li><a href="#the-handshakestate-object">5.3. The <code>HandshakeState</code> object</a></li>
</ul></li>
<li><a href="#prologue">6. Prologue</a></li>
<li><a href="#pre-shared-symmetric-keys">7. Pre-shared symmetric keys</a></li>
<li><a href="#handshake-patterns">8. Handshake patterns</a><ul>
<li><a href="#pattern-validity">8.1 Pattern validity</a></li>
<li><a href="#one-way-patterns">8.2. One-way patterns</a></li>
<li><a href="#interactive-patterns">8.3. Interactive patterns</a></li>
<li><a href="#payload-security-properties">8.4. Payload security properties</a></li>
<li><a href="#identity-hiding">8.5. Identity hiding</a></li>
<li><a href="#more-patterns">8.6. More patterns</a></li>
</ul></li>
<li><a href="#complex-protocols">9. Complex protocols</a><ul>
<li><a href="#dummy-static-public-keys">9.1. Dummy static public keys</a></li>
<li><a href="#handshake-re-initialization-and-noise-pipes">9.2. Handshake re-initialization and Noise Pipes</a></li>
</ul></li>
<li><a href="#dh-functions-cipher-functions-and-hash-functions">10. DH functions, cipher functions, and hash functions</a><ul>
<li><a href="#the-25519-dh-functions">10.1. The <code>25519</code> DH functions</a></li>
<li><a href="#the-448-dh-functions">10.2. The <code>448</code> DH functions</a></li>
<li><a href="#the-chachapoly-cipher-functions">10.3. The <code>ChaChaPoly</code> cipher functions</a></li>
<li><a href="#the-aesgcm-cipher-functions">10.4. The <code>AESGCM</code> cipher functions</a></li>
<li><a href="#the-sha256-hash-function">10.5. The <code>SHA256</code> hash function</a></li>
<li><a href="#the-sha512-hash-function">10.6. The <code>SHA512</code> hash function</a></li>
<li><a href="#the-blake2s-hash-function">10.7. The <code>BLAKE2s</code> hash function</a></li>
<li><a href="#the-blake2b-hash-function">10.8. The <code>BLAKE2b</code> hash function</a></li>
</ul></li>
<li><a href="#protocol-names">11. Protocol names</a></li>
<li><a href="#application-responsibilities">12. Application responsibilities</a></li>
<li><a href="#security-considerations">13. Security considerations</a></li>
<li><a href="#rationale">14. Rationale</a></li>
<li><a href="#ipr">15. IPR</a></li>
<li><a href="#acknowledgements">16. Acknowledgements</a></li>
</ul>
</div>
<h1 id="introduction">1. Introduction</h1>
<p>Noise is a framework for crypto protocols based on Diffie-Hellman key agreement. Noise can describe protocols that consist of a single message as well as interactive protocols.</p>
<h1 id="overview">2. Overview</h1>
<h2 id="terminology">2.1. Terminology</h2>
<p>A Noise protocol begins with two parties exchanging <strong>handshake messages</strong>. During this <strong>handshake phase</strong> the parties exchange DH public keys and perform a sequence of DH operations, hashing the DH results into a shared secret key. After the handshake phase each party can use this shared key to send encrypted <strong>transport messages</strong>.</p>
<p>The Noise framework supports handshakes where each party has a long-term <strong>static key pair</strong> and/or an <strong>ephemeral key pair</strong>. A Noise handshake is described by a simple language. This language consists of <strong>tokens</strong> which are arranged into <strong>message patterns</strong>. Message patterns are arranged into <strong>handshake patterns</strong>.</p>
<p>A <strong>message pattern</strong> is a sequence of tokens that specifies the DH public keys that comprise a handshake message, and the DH operations that are performed when sending or receiving that message. A <strong>handshake pattern</strong> specifies the sequential exchange of messages that comprise a handshake.</p>
<p>A handshake pattern can be instantiated by <strong>DH functions</strong>, <strong>cipher functions</strong>, and a <strong>hash function</strong> to give a concrete <strong>Noise protocol</strong>. An application using a Noise protocol must handle some <strong>application responsibilities</strong> on its own, such as indicating message lengths.</p>
<h2 id="handshake-state-machine">2.2. Handshake state machine</h2>
<p>The core of Noise is a set of variables maintained by each party during a handshake, and rules for sending and receiving handshake messages by sequentially processing the tokens from a message pattern.</p>
<p>Each party maintains the following variables:</p>
<ul>
<li><p><strong><code>s, e</code></strong>: The local party's static and ephemeral key pairs (which may be empty).</p></li>
<li><p><strong><code>rs, re</code></strong>: The remote party's static and ephemeral public keys (which may be empty).</p></li>
<li><p><strong><code>h</code></strong>: A value that hashes all the handshake data that's been sent and received.</p></li>
<li><p><strong><code>ck</code></strong>: A &quot;chaining key&quot; that hashes all previous DH outputs. Once the handshake completes, the chaining key will be used to derive the encryption keys for transport messages.</p></li>
<li><p><strong><code>k, n</code></strong>: An encryption key <code>k</code> (which may be empty) and a counter-based nonce <code>n</code>. Whenever a new DH output causes a new <code>ck</code> to be calculated, a new <code>k</code> is also calculated from the same inputs. The key <code>k</code> and nonce <code>n</code> are used to encrypt static public keys and handshake payloads, incrementing <code>n</code> with each encryption. Encryption with <code>k</code> uses an &quot;AEAD&quot; cipher mode and includes the current <code>h</code> value as &quot;associated data&quot; which is covered by the AEAD authentication tag. Encryption of static public keys and payloads provides some confidentiality and key confirmation during the handshake phase.</p></li>
</ul>
<p>To send a handshake message, the sender sequentially processes each token from a message pattern. The possible tokens are:</p>
<ul>
<li><p><strong><code>&quot;e&quot;</code></strong>: The sender generates a new ephemeral key pair and stores it in the <code>e</code> variable, writes the ephemeral public key as cleartext into the message buffer, and hashes the public key along with the old <code>h</code> to derive a new <code>h</code>.</p></li>
<li><p><strong><code>&quot;s&quot;</code></strong>: The sender writes its static public key from the <code>s</code> variable into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</p></li>
<li><p><strong><code>&quot;dhee&quot;, &quot;dhse&quot;, &quot;dhes&quot;, &quot;dhss&quot;</code></strong>: The sender performs a DH between its corresponding local key pair (whether <code>s</code> or <code>e</code> is determined by the first letter following <code>&quot;dh&quot;</code>) and the remote public key (whether <code>rs</code> or <code>re</code> is determined by the second letter following <code>&quot;dh&quot;</code>). The result is hashed along with the old <code>ck</code> to derive a new <code>ck</code> and <code>k</code>, and <code>n</code> is set to zero.</p></li>
</ul>
<p>After processing the final token in a handshake message, the sender then writes the payload (which may be zero-length) into the message buffer, encrypting it if <code>k</code> is non-empty, and hashes the output along with the old <code>h</code> to derive a new <code>h</code>.</p>
<p>As a simple example, an unauthenticated DH handshake is described by the handshake pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, dhee    </code></pre>
<p>The initiator sends the first message, which is simply an ephemeral public key. The responder sends back its own ephemeral public key. Then a DH is performed and the output is hashed into <code>ck</code>, which is the final shared key from the handshake. Note that a cleartext payload is sent in the first handshake message, and an encrypted payload is sent in the response handshake message. The application may send whatever payloads it wants.</p>
<p>The responder can send its static public key (under encryption) and authenticate itself via a slightly different pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, dhee, s, dhse</code></pre>
<p>In this case, the final <code>ck</code> and <code>k</code> values are a hash of both DH results. Since the <code>dhse</code> token indicates a DH between the initiator's ephemeral key and the responder's static key, successful decryption by the initiator of the second message's payload serves to authenticate the responder to the initiator.</p>
<p>Note that the second message's payload may contain a zero-length plaintext, but the payload ciphertext will still contain an authentication tag, since encryption is with an AEAD mode. The second message's payload can also be used to deliver certificates for the responder's static public key.</p>
<p>The initiator can send <em>its</em> static public key (under encryption), and authenticate itself, using a handshake pattern with one additional message:</p>
<pre><code>  -&gt; e
  &lt;- e, dhee, s, dhse
  -&gt; s, dhse</code></pre>
<p>The following sections flesh out the details, and add some complications (such as pre-shared symmetric keys, and &quot;pre-messages&quot; that represent knowledge of the other party's public keys before the handshake). However, the core of Noise is this simple system of variables, tokens, and processing rules, which allow concise expression of a range of protocols.</p>
<h1 id="message-format">3. Message format</h1>
<p>All Noise messages are less than or equal to 65535 bytes in length. Restricting message size has several advantages:</p>
<ul>
<li><p>Simpler testing, since it's easy to test the maximum sizes.</p></li>
<li><p>Reduces the likelihood of errors in memory handling, or integer overflow.</p></li>
<li><p>Enables support for streaming decryption and random-access decryption of large data streams.</p></li>
<li><p>Enables higher-level protocols that encapsulate Noise messages to use an efficient standard length field of 16 bits.</p></li>
</ul>
<p>All Noise messages can be processed without parsing, since there are no type or length fields. Of course, Noise messages might be encapsulated within a higher-level protocol that contains type and length information. Noise messages might also encapsulate payloads that require parsing of some sort, but the payloads are opaque to Noise.</p>
<p>A Noise <strong>transport message</strong> is simply an AEAD ciphertext that is less than or equal to 65535 bytes in length, and that consists of an encrypted payload plus a 16-byte authentication tag. The details depend on the AEAD cipher function, e.g. AES256-GCM, or ChaCha-Poly1305, but the 16-byte authentication tag typically occurs at the end of the ciphertext.</p>
<p>A Noise <strong>handshake message</strong> is also less than or equal to 65535 bytes. It begins with a sequence of one or more DH public keys, as determined by its message pattern. Following the public keys will be a single payload which can be used to convey certificates or other handshake data, but can also contain a zero-length plaintext.</p>
<p>Static public keys and payloads will be in cleartext if they occur in a handshake pattern prior to a DH operation, and will be an AEAD ciphertext if they occur after a DH operation. (If Noise is being used with pre-shared symmetric keys, this rule is different: <em>all</em> static public keys and payloads will be encrypted; see <a href="#pre-shared-symmetric-keys">Section 7</a>). Like transport messages, AEAD ciphertexts will expand each encrypted field (whether static public key or payload) by 16 bytes.</p>
<p>For an example, consider the handshake pattern:</p>
<pre><code>  -&gt; e
  &lt;- e, dhee, s, dhse
  -&gt; s, dhse</code></pre>
<p>The first message consists of a cleartext public key (<code>&quot;e&quot;</code>) followed by a cleartext payload (remember that a payload is implicit at the end of each message pattern). The second message consists of a cleartext public key (<code>&quot;e&quot;</code>) followed by an encrypted public key (<code>&quot;s&quot;</code>) followed by an encrypted payload. The third message consists of an encrypted public key (<code>&quot;s&quot;</code>) followed by an encrypted payload.</p>
<p>Assuming each payload contains a zero-length plaintext, and DH public keys are 56 bytes, the message sizes will be:</p>
<ol style="list-style-type: decimal">
<li><p>56 bytes (one cleartext public key and a cleartext payload)</p></li>
<li><p>144 bytes (two public keys, the second encrypted, and an encrypted payload)</p></li>
<li><p>88 bytes (one encrypted public key and an encrypted payload)</p></li>
</ol>
<p>If pre-shared symmetric keys are used, the first message grows in size to 72 bytes, since the first payload becomes encrypted.</p>
<h1 id="crypto-functions">4. Crypto functions</h1>
<p>A Noise protocol is instantiated with a concrete set of <strong>DH functions</strong>, <strong>cipher functions</strong>, and a <strong>hash function</strong>. The signature for these functions is defined below. Some concrete functions are defined in <a href="#dh-functions-cipher-functions-and-hash-functions">Section 10</a>.</p>
<p>Noise depends on the following <strong>DH functions</strong> (and an associated constant):</p>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Generates a new DH keypair.</p></li>
<li><p><strong><code>DH(privkey, pubkey)</code></strong>: Performs a DH calculation and returns an output sequence of bytes. If the function detects an invalid public key, the output may be all zeros or any other value that doesn't leak information about the private key. For reasons discussed in <a href="#dummy-static-public-keys">Section 9.1</a> it is recommended for the function to have a <strong>null public key value</strong> that always yields the same output, regardless of private key. For example, the DH functions in <a href="#dh-functions-cipher-functions-and-hash-functions">Section 10</a> always map a DH public key of all zeros to an output of all zeros.</p></li>
<li><p><strong><code>DHLEN</code></strong> = A constant specifying the size of public keys in bytes.</p></li>
</ul>
<p>Noise depends on the following <strong>cipher functions</strong>:</p>
<ul>
<li><p><strong><code>ENCRYPT(k, n, ad, plaintext)</code></strong>: Encrypts <code>plaintext</code> using the cipher key <code>k</code> of 32 bytes and an 8-byte unsigned integer nonce <code>n</code> which must be unique for the key <code>k</code>. Returns the ciphertext. Encryption must be done with an &quot;AEAD&quot; encryption mode with the associated data <code>ad</code> and returns a ciphertext that is the same size as the plaintext plus 16 bytes for an authentication tag.</p></li>
<li><p><strong><code>DECRYPT(k, n, ad, ciphertext)</code></strong>: Decrypts <code>ciphertext</code> using a cipher key <code>k</code> of 32 bytes, an 8-byte unsigned integer nonce <code>n</code>, and associated data <code>ad</code>. Returns the plaintext, unless authentication fails, in which case an error is signaled to the caller.</p></li>
</ul>
<p>Noise depends on the following <strong>hash function</strong> (and associated constants):</p>
<ul>
<li><p><strong><code>HASH(data)</code></strong>: Hashes some arbitrary-length data with a collision-resistant hash function and returns an output of <code>HASHLEN</code> bytes.</p></li>
<li><p><strong><code>HASHLEN</code></strong> = A constant specifying the size in bytes of the hash output. Must be 32 or 64.</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = A constant specifying the size in bytes that the hash function uses internally to divide its input for iterative processing. This is needed to use the hash function with HMAC (<code>BLOCKLEN</code> is <code>B</code> in <a href="https://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a>).</p></li>
</ul>
<p>Noise defines an additional function based on the above <code>HASH()</code> function:</p>
<ul>
<li><p><strong><code>HKDF(chaining_key, input_key_material)</code></strong>: Takes a <code>chaining_key</code> byte sequence of length <code>HASHLEN</code>, and an <code>input_key_material</code> byte sequence of arbitrary length. Returns two byte sequences of length <code>HASHLEN</code>, as follows. (The <code>HMAC-HASH(key, data)</code> function applies <code>HMAC</code> from <a href="https://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> using the <code>HASH()</code> function; the <code>||</code> operator concatenates byte sequences; the <code>byte()</code> function constructs a single byte):</p>
<ul>
<li><p>Sets <code>temp_key = HMAC-HASH(chaining_key, input_key_material)</code>.</p></li>
<li><p>Sets <code>output1 = HMAC-HASH(temp_key, byte(0x01))</code>.</p></li>
<li><p>Sets <code>output2 = HMAC-HASH(temp_key, output1 || byte(0x02))</code>.</p></li>
<li><p>Returns the pair <code>(output1, output2)</code>.</p></li>
</ul></li>
</ul>
<p>Note that <code>temp_key</code>, <code>output1</code>, and <code>output2</code> are all <code>HASHLEN</code> bytes in length.</p>
<h1 id="processing-rules-for-handshake-and-transport-messages">5. Processing rules for handshake and transport messages</h1>
<p>To precisely define the processing rules we adopt an object-oriented terminology, and present three &quot;objects&quot; which encapsulate state variables and provide &quot;methods&quot; which implement processing logic. These three objects are presented as a hierarchy: each higher-layer object includes one instance of the object beneath it. From lowest-layer to highest, the objects are:</p>
<ul>
<li><p>A <strong><code>CipherState</code></strong> object contains <code>k</code> and <code>n</code> variables, which it uses to encrypt and decrypt ciphertexts. During the handshake phase each party has a single <code>CipherState</code>, but during the transport phase each party has two <code>CipherState</code> objects: one for sending, and one for receiving.</p></li>
<li><p>A <strong><code>SymmetricState</code></strong> object contains a <code>CipherState</code> plus <code>ck</code> and <code>h</code> variables. It is so-named because it encapsulates all the &quot;symmetric crypto&quot; used by Noise. During the handshake phase each party has a single <code>SymmetricState</code>, which can be deleted once the handshake is finished.</p></li>
<li><p>A <strong><code>HandshakeState</code></strong> object contains a <code>SymmetricState</code> plus DH variables <code>(s, e, rs, re)</code> and some variables representing the handshake pattern. During the handshake phase each party has a single <code>HandshakeState</code>, which can be deleted once the handshake is finished.</p></li>
</ul>
<p>To execute a Noise protocol you <code>Initialize()</code> a <code>HandshakeState</code>. During initialization you specify the handshake pattern, any local key pairs, and any public keys for the remote party you have knowledge of. After <code>Initialize()</code> you call <code>WriteMessage()</code> and <code>ReadMessage()</code> on the <code>HandshakeState</code> to process each handshake message. If a decryption error occurs the handshake has failed and the <code>HandshakeState</code> is deleted without sending further messages.</p>
<p>Processing the final handshake message returns two <code>CipherState</code> objects, the first for encrypting transport messages from initiator to responder, and the second for messages in the other direction. At that point the <code>HandshakeState</code> may be deleted. Transport messages are then encrypted and decrypted by calling <code>EncryptWithAd()</code> and <code>DecryptWithAd()</code> on the relevant <code>CipherState</code> with zero-length associated data.</p>
<p>The below sections describe these objects in detail.</p>
<h2 id="the-cipherstate-object">5.1 The <code>CipherState</code> object</h2>
<p>A <code>CipherState</code> can encrypt and decrypt data based on its <code>k</code> and <code>n</code> variables:</p>
<ul>
<li><p><strong><code>k</code></strong>: A cipher key of 32 bytes (which may be <code>empty</code>). <code>Empty</code> is a special value which indicates <code>k</code> has not yet been initialized.</p></li>
<li><p><strong><code>n</code></strong>: An 8-byte (64-bit) unsigned integer nonce.</p></li>
</ul>
<p>A <code>CipherState</code> responds to the following methods. The <code>++</code> post-increment operator applied to <code>n</code> means &quot;use the current <code>n</code> value, then increment it&quot;. If incrementing <code>n</code> causes an arithmetic overflow (i.e. would result in <code>n</code> greater than 2^64 - 1) then any further <code>Encrypt()</code> or <code>Decrypt()</code> calls will signal an error to the caller.</p>
<ul>
<li><p><strong><code>InitializeKey(key)</code></strong>: Sets <code>k = key</code>. Sets <code>n = 0</code>.</p></li>
<li><p><strong><code>HasKey()</code></strong>: Returns true if <code>k</code> is non-empty, false otherwise.</p></li>
<li><p><strong><code>EncryptWithAd(ad, plaintext)</code></strong>: If <code>k</code> is non-empty returns <code>ENCRYPT(k, n++, ad, plaintext)</code>. Otherwise returns <code>plaintext</code>.</p></li>
<li><p><strong><code>DecryptWithAd(ad, ciphertext)</code></strong>: If <code>k</code> is non-empty returns <code>DECRYPT(k, n++, ad, ciphertext)</code>. Otherwise returns <code>ciphertext</code>. If an authentication failure occurs in <code>DECRYPT()</code> the error is signaled to the caller.</p></li>
</ul>
<h2 id="the-symmetricstate-object">5.2. The <code>SymmetricState</code> object</h2>
<p>A <code>SymmetricState</code> object contains a <code>CipherState</code> plus the following variables:</p>
<ul>
<li><p><strong><code>ck</code></strong>: A chaining key of <code>HASHLEN</code> bytes.</p></li>
<li><p><strong><code>h</code></strong>: A hash output of <code>HASHLEN</code> bytes.</p></li>
</ul>
<p>A <code>SymmetricState</code> responds to the following methods:</p>
<ul>
<li><strong><code>InitializeSymmetric(protocol_name)</code></strong>: Takes an arbitrary-length <code>protocol_name</code> byte sequence (see <a href="#protocol-names">Section 11</a>). Executes the following steps:
<ul>
<li><p>If <code>protocol_name</code> is less than or equal to <code>HASHLEN</code> bytes in length, sets <code>h</code> equal to <code>protocol_name</code> with zero bytes appended to make <code>HASHLEN</code> bytes. Otherwise sets <code>h = HASH(protocol_name)</code>.</p></li>
<li><p>Sets <code>ck = h</code>.</p></li>
<li><p>Calls <code>InitializeKey(empty)</code>.</p></li>
</ul></li>
<li><p><strong><code>MixKey(input_key_material)</code></strong>: Sets <code>ck, temp_k = HKDF(ck, input_key_material)</code>. If <code>HASHLEN</code> is 64, then <code>temp_k</code> is truncated to 32 bytes to match <code>k</code>. Calls <code>InitializeKey(temp_k)</code>.</p></li>
<li><p><strong><code>MixHash(data)</code></strong>: Sets <code>h = HASH(h || data)</code>.</p></li>
<li><p><strong><code>EncryptAndHash(plaintext)</code></strong>: Sets <code>ciphertext = EncryptWithAd(h, plaintext)</code>, calls <code>MixHash(ciphertext)</code>, and returns <code>ciphertext</code>.</p></li>
<li><p><strong><code>DecryptAndHash(ciphertext)</code></strong>: Sets <code>plaintext = DecryptWithAd(h, ciphertext)</code>, calls <code>MixHash(ciphertext)</code>, and returns <code>plaintext</code>.</p></li>
<li><p><strong><code>Split()</code></strong>: Returns a pair of <code>CipherState</code> objects for encrypting transport messages. Executes the following steps:</p>
<ul>
<li><p>Sets <code>temp_k1, temp_k2 = HKDF(ck, zerolen)</code> where <code>zerolen</code> is a zero-length byte sequence.</p></li>
<li><p>If <code>HASHLEN</code> is 64, then truncates <code>temp_k1</code> and <code>temp_k2</code> to 32 bytes apiece to match <code>k</code>.</p></li>
<li><p>Creates two new <code>CipherState</code> objects <code>c1</code> and <code>c2</code>.</p></li>
<li><p>Calls <code>c1.InitializeKey(temp_k1)</code> and <code>c2.InitializeKey(temp_k2)</code>.</p></li>
<li><p>Returns the pair <code>(c1, c2)</code>.</p></li>
</ul></li>
</ul>
<h2 id="the-handshakestate-object">5.3. The <code>HandshakeState</code> object</h2>
<p>A <code>HandshakeState</code> object contains a <code>SymmetricState</code> plus the following variables, any of which may be <code>empty</code>. <code>Empty</code> is a special value which indicates the variable has not yet been initialized.</p>
<ul>
<li><p><strong><code>s</code></strong>: The local static key pair</p></li>
<li><p><strong><code>e</code></strong>: The local ephemeral key pair</p></li>
<li><p><strong><code>rs</code></strong>: The remote party's static public key</p></li>
<li><p><strong><code>re</code></strong>: The remote party's ephemeral public key</p></li>
</ul>
<p>A <code>HandshakeState</code> also has the following variables:</p>
<ul>
<li><p><strong><code>message_patterns</code></strong>: A sequence of message patterns. Each message pattern is a sequence of tokens from the set <code>(&quot;s&quot;, &quot;e&quot;, &quot;dhee&quot;, &quot;dhes&quot;, &quot;dhse&quot;, &quot;dhss&quot;)</code>.</p></li>
<li><p><strong><code>message_index</code></strong>: An integer indicating the next pattern to fetch from <code>message_patterns</code>.</p></li>
</ul>
<p>A <code>HandshakeState</code> responds to the following methods:</p>
<ul>
<li><p><strong><code>Initialize(handshake_pattern, initiator, prologue, s, e, rs, re)</code></strong>: Takes a valid handshake pattern (see <a href="#handshake-patterns">Section 8</a>) and an <code>initiator</code> boolean specifying this party's role as either initiator or responder. Takes a <code>prologue</code> byte sequence which may be zero-length, or which may contain context information that both parties want to confirm is identical (see <a href="#prologue">Section 6</a>). Takes a set of DH keypairs and public keys for initializing local variables, any of which may be empty.</p>
<ul>
<li><p>Derives a <code>protocol_name</code> byte sequence by combining the names for the handshake pattern and crypto functions, as specified in <a href="#protocol-names">Section 11</a>. Calls <code>InitializeSymmetric(protocol_name)</code>.</p></li>
<li><p>Calls <code>MixHash(prologue)</code>.</p></li>
<li><p>Sets the <code>s</code>, <code>e</code>, <code>rs</code>, and <code>re</code> variables to the corresponding arguments.</p></li>
<li><p>Calls <code>MixHash()</code> once for each public key listed in the pre-messages from <code>handshake_pattern</code>, with the specified public key as input (see <a href="#handshake-patterns">Section 8</a> for an explanation of pre-messages). If both initiator and responder have pre-messages, the initiator's public keys are hashed first.</p></li>
<li><p>Sets <code>message_patterns</code> to the message patterns from <code>handshake_pattern</code>.</p></li>
<li><p>Sets <code>message_index = 0</code> (i.e. the first message pattern).</p></li>
</ul></li>
<li><p><strong><code>WriteMessage(payload, message_buffer)</code></strong>: Takes a <code>payload</code> byte sequence which may be zero-length, and a <code>message_buffer</code> to write the output into.</p>
<ul>
<li><p>Fetches the next message pattern from <code>message_patterns[message_index]</code>, increments <code>message_index</code>, and sequentially processes each token from the message pattern:</p></li>
<li><p>For <code>&quot;e&quot;</code>: Sets <code>e = GENERATE_KEYPAIR()</code>, overwriting any previous value for <code>e</code>. Appends <code>e.public_key</code> to the buffer. Calls <code>MixHash(e.public_key)</code>.</p></li>
<li><p>For <code>&quot;s&quot;</code>: Appends <code>EncryptAndHash(s.public_key)</code> to the buffer.</p></li>
<li><p>For <code>&quot;dhxy&quot;</code>: Calls <code>MixKey(DH(x, ry))</code>.</p></li>
<li><p>Appends <code>EncryptAndHash(payload)</code> to the buffer.</p></li>
<li><p>If there are no more message patterns returns two new <code>CipherState</code> objects by calling <code>Split()</code>.</p></li>
</ul></li>
<li><p><strong><code>ReadMessage(message, payload_buffer)</code></strong>: Takes a byte sequence containing a Noise handshake message, and a <code>payload_buffer</code> to write the message's plaintext payload into.</p>
<ul>
<li><p>Fetches the message pattern from <code>message_patterns[message_index]</code>, increments <code>message_index</code>, and sequentially processes each token from the message pattern:</p></li>
<li><p>For <code>&quot;e&quot;</code>: Sets <code>re</code> to the next <code>DHLEN</code> bytes from the message. Calls <code>MixHash(re.public_key)</code>.</p></li>
<li><p>For <code>&quot;s&quot;</code>: Sets <code>temp</code> to the next <code>DHLEN + 16</code> bytes of the message if <code>HasKey() == True</code>, or to the next <code>DHLEN</code> bytes otherwise. Sets <code>rs</code> to <code>DecryptAndHash(temp)</code>.</p></li>
<li><p>For <code>&quot;dhxy&quot;</code>: Calls <code>MixKey(DH(y, rx))</code>.</p></li>
<li><p>Calls <code>DecryptAndHash()</code> on the remaining bytes of the message and stores the output into <code>payload_buffer</code>.</p></li>
<li><p>If there are no more message patterns returns two new <code>CipherState</code> objects by calling <code>Split()</code>.</p></li>
</ul></li>
</ul>
<h1 id="prologue">6. Prologue</h1>
<p>Noise handshakes have a <strong>prologue</strong> input which allows arbitrary data to be hashed into the <code>h</code> variable. If both parties do not provide identical prologue data, the handshake will fail due to a decryption error. This is useful when the parties engaged in negotiation prior to the handshake and want to ensure they share identical views of that negotiation.</p>
<p>For example, suppose Bob communicates to Alice a list of Noise protocols that he is willing to support. Alice will then choose and execute a single protocol. To ensure that a &quot;man-in-the-middle&quot; did not edit Bob's list to remove options, Alice and Bob could include the list as prologue data.</p>
<p>Note that while the parties confirm their prologues are identical, they don't mix prologue data into encryption keys. If an input contains secret data that's intended to strengthen the encryption, a &quot;PSK&quot; handshake should be used instead (see next section).</p>
<h1 id="pre-shared-symmetric-keys">7. Pre-shared symmetric keys</h1>
<p>Noise provides an optional <strong>pre-shared symmetric key</strong> or <strong>PSK</strong> mode to support protocols where both parties already have a shared secret key. When using pre-shared symmetric keys, the following changes are made:</p>
<ul>
<li><p>Protocol names (<a href="#protocol-names">Section 11</a>) use the prefix <code>&quot;NoisePSK_&quot;</code> instead of <code>&quot;Noise_&quot;</code>.</p></li>
<li><p><code>Initialize()</code> takes an additional <code>psk</code> argument, which is a sequence of bytes. Immediately after <code>MixHash(prologue)</code> it sets <code>ck, temp = HKDF(ck,    psk)</code>, then calls <code>MixHash(temp)</code>. This mixes the pre-shared key into the chaining key, and also mixes a one-way function of the pre-shared key into the <code>h</code> value to ensure that <code>h</code> is a function of all handshake inputs.</p></li>
<li><p><code>WriteMessage()</code> and <code>ReadMessage()</code> are modified when processing the <code>&quot;e&quot;</code> token to call <code>MixKey(e.public_key)</code> as the final step. Because the initial messages in a handshake pattern are required to start with <code>&quot;e&quot;</code> (<a href="#pattern-validity">Section 8.1</a>), this ensures <code>k</code> is initialized from the pre-shared key. This also uses the ephemeral public key's value as a random nonce to prevent re-using the same <code>k</code> and <code>n</code> for different messages.</p></li>
</ul>
<h1 id="handshake-patterns">8. Handshake patterns</h1>
<p>A <strong>message pattern</strong> is some sequence of tokens from the set <code>(&quot;e&quot;, &quot;s&quot;, &quot;dhee&quot;, &quot;dhes&quot;, &quot;dhse&quot;, &quot;dhss&quot;)</code>. A <strong>handshake pattern</strong> consists of:</p>
<ul>
<li>A pattern for the initiator's <strong>pre-message</strong> that is either:
<ul>
<li><code>&quot;s&quot;</code></li>
<li><code>&quot;e&quot;</code></li>
<li><code>&quot;s, e&quot;</code></li>
<li>empty</li>
</ul></li>
<li><p>A pattern for the responder's pre-message that takes the same range of values as the initiator's pre-message.</p></li>
<li><p>A sequence of message patterns for the actual handshake messages</p></li>
</ul>
<p>The pre-messages represent an exchange of public keys that was somehow performed prior to the handshake, so these public keys must be inputs to <code>Initialize()</code> for the &quot;recipient&quot; of the pre-message.</p>
<p>The first actual handshake message is sent from the initiator to the responder, the next is sent by the responder, the next from the initiator, and so on in alternating fashion.</p>
<p>The following handshake pattern describes an unauthenticated DH handshake:</p>
<pre><code>Noise_NN():
  -&gt; e
  &lt;- e, dhee</code></pre>
<p>The handshake pattern name is <code>Noise_NN</code>. This naming convention will be explained in <a href="#interactive-patterns">Section 8.3</a>. The empty parentheses indicate that neither party is initialized with any key pairs. The tokens <code>&quot;s&quot;</code> and/or <code>&quot;e&quot;</code> inside the parentheses would indicate that the initiator is initialized with static and/or ephemeral key pairs. The tokens <code>&quot;rs&quot;</code> and/or <code>&quot;re&quot;</code> would indicate the same thing for the responder.</p>
<p>Pre-messages are shown as patterns prior to the delimiter &quot;...&quot;, with a right-pointing arrow for the initiator's pre-message, and a left-pointing arrow for the responder's pre-message. If both parties have a pre-message, the initiator's is listed first (and hashed first). During <code>Initialize()</code>, <code>MixHash()</code> is called on any pre-message public keys, as described in <a href="#the-handshakestate-object">Section 5.3</a>.</p>
<p>The following pattern describes a handshake where the initiator has pre-knowledge of the responder's static public key, and performs a DH with the responder's static public key as well as the responder's ephemeral public key. This pre-knowledge allows an encrypted payload to be sent in the first message, although full forward secrecy and replay protection is only achieved with the second message.</p>
<pre><code>Noise_NK(rs):
  &lt;- s
  ...
  -&gt; e, dhes 
  &lt;- e, dhee</code></pre>
<h2 id="pattern-validity">8.1 Pattern validity</h2>
<p>Noise patterns must be <strong>valid</strong> in the following senses:</p>
<ul>
<li><p>Parties can only send a static public key if they were initialized with a static key pair, and can only perform DH between private keys and public keys they possess.</p></li>
<li><p>Parties must send a fresh ephemeral public key at the start of the first message they send (i.e. the first token of the first message pattern in each direction must be <code>&quot;e&quot;</code>).</p></li>
<li><p>After performing a DH between a remote public key and any local private key that is not a &quot;fresh&quot; ephemeral private key, the local party must not send any payloads or static public keys, nor complete the handshake, unless they have also performed a DH between a &quot;fresh&quot; ephemeral private key and the remote public key. A &quot;fresh&quot; ephemeral private key is one that was created by processing an <code>&quot;e&quot;</code> token when sending a message (as opposed to an ephemeral private key passed in during initialization).</p></li>
</ul>
<p>Patterns failing the first check will obviously abort the program.</p>
<p>The second and third checks are necessary because Noise uses DH outputs involving ephemeral keys to randomize the shared secret keys. Noise also uses ephemeral public keys to randomize PSK-based encryption. Patterns failing these checks could result in subtle but catastrophic security flaws.</p>
<p>Users are recommended to only use the handshake patterns listed below, or other patterns that have been vetted by experts to satisfy the above checks.</p>
<h2 id="one-way-patterns">8.2. One-way patterns</h2>
<p>The following example handshake patterns represent &quot;one-way&quot; handshakes supporting a one-way stream of data from a sender to a recipient. These patterns could be used to encrypt files, database records, or other non-interactive data streams.</p>
<p>Following a one-way handshake the sender can send a stream of transport messages, encrypting them using the first <code>CipherState</code> returned by <code>Split()</code>. The second <code>CipherState</code> from <code>Split()</code> is discarded - the recipient must not send any messages using it (as this would violate the rules in <a href="#pattern-validity">Section 8.1</a>).</p>
<pre><code>Naming convention for one-way patterns:    
  N = no static key for sender
  K = static key for sender known to recipient
  X = static key for sender transmitted to recipient

Noise_N(rs):
  &lt;- s
  ...
  -&gt; e, dhes

Noise_K(s, rs):
  -&gt; s
  &lt;- s
  ...
  -&gt; e, dhes, dhss

Noise_X(s, rs):
  &lt;- s
  ...
  -&gt; e, dhes, s, dhss</code></pre>
<p><code>Noise_N</code> is a conventional DH-based public-key encryption. The other patterns add sender authentication, where the sender's public key is either known to the recipient beforehand (<code>Noise_K</code>) or transmitted under encryption (<code>Noise_X</code>).</p>
<h2 id="interactive-patterns">8.3. Interactive patterns</h2>
<p>The following example handshake patterns represent interactive protocols.</p>
<pre><code>Naming convention for interactive patterns:

  N_ = no static key for initiator
  K_ = static key for initiator known to responder
  X_ = static key for initiator transmitted to responder
  I_ = static key for initiator immediately transmitted to responder,
       despite reduced or absent identity-hiding

  _N = no static key for responder
  _K = static key for responder known to initiator
  _X = static key for responder transmitted to initiator
  _R = static key for responder transmitted to initiator, but only 
       after the initiator has revealed their identity


Noise_NN():                      Noise_KN(s):              
  -&gt; e                             -&gt; s                       
  &lt;- e, dhee                       ...                        
                                   -&gt; e                       
                                   &lt;- e, dhee, dhes           
                                         
Noise_NK(rs):                    Noise_KK(s, rs):
  &lt;- s                             -&gt; s                       
  ...                              &lt;- s                       
  -&gt; e, dhes                       ...                        
  &lt;- e, dhee                       -&gt; e, dhes, dhss           
                                   &lt;- e, dhee, dhes           
                                          
Noise_NX(rs):                    Noise_KX(s, rs):          
  -&gt; e                             -&gt; s                       
  &lt;- e, dhee, s, dhse              ...                        
                                   -&gt; e                       
                                   &lt;- e, dhee, dhes, s, dhse  


Noise_XN(s):                     Noise_IN(s):
  -&gt; e                             -&gt; e, s
  &lt;- e, dhee                       &lt;- e, dhee, dhes             
  -&gt; s, dhse                                                     
                                     
Noise_XK(s, rs):                 Noise_IK(s, rs):            
  &lt;- s                             &lt;- s                         
  ...                              ...                          
  -&gt; e, dhes                       -&gt; e, dhes, s, dhss          
  &lt;- e, dhee                       &lt;- e, dhee, dhes             
  -&gt; s, dhse                                                     
                                    
Noise_XX(s, rs):                 Noise_IX(s, rs):
  -&gt; e                             -&gt; e, s
  &lt;- e, dhee, s, dhse              &lt;- e, dhee, dhes, s, dhse 
  -&gt; s, dhse

Noise_XR(s, rs):
  -&gt; e
  &lt;- e, dhee
  -&gt; s, dhse
  &lt;- s, dhse</code></pre>
<p>The <code>Noise_XX</code> pattern is the most generically useful, since it is efficient and supports mutual authentication and transmission of static public keys. The <code>Noise_XR</code> pattern is similar to <code>Noise_XX</code> but is less efficient, and offers stronger identity-hiding for the responder rather than the initiator. (This is similar to the distinction between SIGMA-I and SIGMA-R; see <a href="#identity-hiding">Section 8.5</a> for more analysis on identity-hiding.)</p>
<p>All interactive patterns allow some encryption of handshake payloads:</p>
<ul>
<li><p>Patterns where the initiator has pre-knowledge of the responder's static public key (i.e. patterns ending in <code>&quot;K&quot;</code>) allow &quot;zero-RTT&quot; encryption, meaning the initiator can encrypt the first handshake payload.</p></li>
<li><p>All interactive patterns allow &quot;half-RTT&quot; encryption of the first response payload, but the encryption only targets an initiator static public key in patterns starting with &quot;K&quot; or &quot;I&quot;.</p></li>
</ul>
<p>The security properties for handshake payloads are usually weaker than the final security properties achieved by transport payloads, so these early encryptions must be used with caution.</p>
<p>In some patterns the security properties of transport payloads can also vary. In particular: patterns starting with &quot;K&quot; or &quot;I&quot; have the caveat that the responder is only guaranteed &quot;weak&quot; forward secrecy for the transport messages it sends until it receives a transport message from the initiator. After receiving a transport message from the initiator, the responder becomes assured of &quot;strong&quot; forward secrecy.</p>
<p>The next section provides more analysis of these payload security properties.</p>
<h2 id="payload-security-properties">8.4. Payload security properties</h2>
<p>The following table lists the security properties for Noise handshake and transport payloads for all the named patterns in <a href="#one-way-patterns">Section 8.2</a> and <a href="#interactive-patterns">Section 8.3</a>. Each payload is assigned an &quot;authentication&quot; property regarding the degree of authentication of the sender provided to the recipient, and a &quot;confidentiality&quot; property regarding the degree of confidentiality provided to the sender.</p>
<p>The authentication properties are:</p>
<ul>
<li><p><strong>0 = No authentication.</strong> This payload may have been sent by any party, including an active attacker.</p></li>
<li><p><strong>1 = Sender authentication <em>vulnerable</em> to key-compromise impersonation (KCI)</strong>. The sender authentication is based on a static-static DH (<code>&quot;dhss&quot;</code>) involving both parties' static key pairs. If the recipient's long-term private key has been compromised, this authentication can be forged. Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>2 = Sender authentication <em>resistant</em> to key-compromise impersonation (KCI)</strong>. The sender authentication is based on an ephemeral-static DH (<code>&quot;dhes&quot;</code> or <code>&quot;dhse&quot;</code>) between the sender's static key pair and the recipient's ephemeral key pair. Assuming the corresponding private keys are secure, this authentication cannot be forged.</p></li>
</ul>
<p>The confidentiality properties are:</p>
<ul>
<li><p><strong>0 = No confidentiality.</strong> This payload is sent in cleartext.</p></li>
<li><p><strong>1 = Encryption to an ephemeral recipient.</strong> This payload has forward secrecy, since encryption involves an ephemeral-ephemeral DH (<code>&quot;dhee&quot;</code>). However, the sender has not authenticated the recipient, so this payload might be sent to any party, including an active attacker.</p></li>
<li><p><strong>2 = Encryption to a known recipient, forward secrecy for sender compromise only, vulnerable to replay.</strong> This payload is encrypted based only on DHs involving the recipient's static key pair. If the recipient's static private key is compromised, even at a later date, this payload can be decrypted. This message can also be replayed, since there's no ephemeral contribution from the recipient.</p></li>
<li><p><strong>3 = Encryption to a known recipient, weak forward secrecy.</strong> This payload is encrypted based on an ephemeral-ephemeral DH and also an ephemeral-static DH involving the recipient's static key pair. However, the binding between the recipient's alleged ephemeral public key and the recipient's static public key hasn't been verified by the sender, so the recipient's alleged ephemeral public key may have been forged by an active attacker. In this case, the attacker could later compromise the recipient's static private key to decrypt the payload. Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>4 = Encryption to a known recipient, weak forward secrecy if the sender's private key has been compromised.</strong> This payload is encrypted based on an ephemeral-ephemeral DH, and also based on an ephemeral-static DH involving the recipient's static key pair. However, the binding between the recipient's alleged ephemeral public and the recipient's static public key has only been verified based on DHs involving both those public keys and the sender's static private key. Thus, if the sender's static private key was previously compromised, the recipient's alleged ephemeral public key may have been forged by an active attacker. In this case, the attacker could later compromise the intended recipient's static private key to decrypt the payload (this is a variant of a &quot;KCI&quot; attack enabling a &quot;weak forward secrecy&quot; attack). Note that a future version of Noise might include signatures, which could improve this security property, but brings other trade-offs.</p></li>
<li><p><strong>5 = Encryption to a known recipient, strong forward secrecy.</strong> This payload is encrypted based on an ephemeral-ephemeral DH and well as an ephemeral-static DH with the recipient's static key pair. Assuming the ephemeral private keys are secure, and the recipient is not being actively impersonated by an attacker that has stolen its static private key, this payload cannot be decrypted.</p></li>
</ul>
<p>For one-way handshakes, the below-listed security properties apply to the handshake payload as well as transport payloads.</p>
<p>For interactive handshakes, security properties are listed for each handshake payload. Transport payloads are listed as arrows without a pattern. Transport payloads are only listed if they have different security properties than the previous handshake payload sent from the same party. If two transport payloads are listed, the security properties for the second only apply if the first was received.</p>
<pre><code>                         Authentication   Confidentiality
                         --------------   ---------------
Noise_N                         0                2
Noise_K                         1                2
Noise_X                         1                2                  
                                                                    
                                                                    
Noise_NN                                                            
  -&gt; e                          0                0
  &lt;- e, dhee                    0                1
  -&gt;                            0                1
                                                                    
Noise_NK                                                            
  &lt;- s                                                              
  ...                                                               
  -&gt; e, dhes                    0                2                 
  &lt;- e, dhee                    2                1                 
  -&gt;                            0                5                 
                                                                    
Noise_NX                                                            
  -&gt; e                          0                0                  
  &lt;- e, dhee, s, dhse           2                1                 
  -&gt;                            0                5                 
                                                                    
                                                                    
Noise_XN                                                            
  -&gt; e                          0                0                 
  &lt;- e, dhee                    0                1                 
  -&gt; s, dhse                    2                1                 
  &lt;-                            0                5                 
                                                                    
Noise_XK                                                            
  &lt;- s                                                              
  ...                                                               
  -&gt; e, dhes                    0                2                 
  &lt;- e, dhee                    2                1                 
  -&gt; s, dhse                    2                5                 
  &lt;-                            2                5                 
                                                                    
Noise_XX                                                            
 -&gt; e                           0                0                 
 &lt;- e, dhee, s, dhse            2                1                 
 -&gt; s, dhse                     2                5                 
 &lt;-                             2                5                 
                                                                    
Noise_XR                                                            
  -&gt; e                          0                0                  
  &lt;- e, dhee                    0                1                 
  -&gt; s, dhse                    2                1                 
  &lt;- s, dhse                    2                5                 
  -&gt;                            2                5                 
                                                                    
                                                                    
Noise_KN                                                            
  -&gt; s                                                              
  ...                                                               
  -&gt; e                          0                0                  
  &lt;- e, dhee, dhes              0                3                 
  -&gt;                            2                1                 
  &lt;-                            0                5                 
                                                                    
Noise_KK                                                            
  -&gt; s                                                              
  &lt;- s                                                              
  ...                                                               
  -&gt; e, dhes, dhss              1                2                 
  &lt;- e, dhee, dhes              2                4                 
  -&gt;                            2                5                 
  &lt;-                            2                5                 
                                                                 
Noise_KX                                                            
  -&gt; s                                                              
  ...                                                               
  -&gt; e                          0                0               
  &lt;- e, dhee, dhes, s, dhse     2                3               
  -&gt;                            2                5               
  &lt;-                            2                5               
                                                                 
                                                                 
Noise_IN                                                         
  -&gt; e, s                       0                0               
  &lt;- e, dhee, dhes              0                3               
  -&gt;                            2                1               
  &lt;-                            0                5               
                                                                 
Noise_IK                                                         
  &lt;- s                                                           
  ...                                                            
  -&gt; e, dhes, s, dhss           1                2               
  &lt;- e, dhee, dhes              2                4               
  -&gt;                            2                5               
  &lt;-                            2                5               
                                                                 
Noise_IX                                                         
  -&gt; e, s                       0                0               
  &lt;- e, dhee, dhes, s, dhse     2                3               
  -&gt;                            2                5               
  &lt;-                            2                5               </code></pre>
<h2 id="identity-hiding">8.5. Identity hiding</h2>
<p>The following table lists the identity hiding properties for all the named patterns in <a href="#one-way-patterns">Section 8.2</a> and <a href="#interactive-patterns">Section 8.3</a>. Each pattern is assigned properties describing the confidentiality supplied to the initiator's static public key, and to the responder's static public key. The underlying assumptions are that ephemeral private keys are secure, and that parties abort the handshake if they receive a static public key from the other party which they don't trust.</p>
<p>This section only considers identity leakage through static public key fields in handshakes. Of course, the identities of Noise participants might be exposed through other means, including payload fields, traffic analysis, or metadata such as IP addresses.</p>
<p>The properties for the relevant public key are:</p>
<ul>
<li><p><strong>0.</strong> Transmitted in clear.</p></li>
<li><p><strong>1.</strong> Encrypted with forward secrecy, but can be probed by an anonymous initiator.</p></li>
<li><p><strong>2.</strong> Encrypted with forward secrecy, but sent to an anonymous responder.</p></li>
<li><p><strong>3.</strong> Not transmitted, but a passive attacker can check candidates for the responder's private key and determine whether the candidate is correct.</p></li>
<li><p><strong>4.</strong> Encrypted to responder's static public key, without forward secrecy. If an attacker learns the responder's private key they can decrypt the initiator's public key.</p></li>
<li><p><strong>5.</strong> Not transmitted, but a passive attacker can check candidates for the responder's private key and initiator's public key and determine if both candidates are correct.</p></li>
<li><p><strong>6.</strong> Encrypted but with weak forward secrecy. An active attacker who pretends to be the initiator without the initiator's static private key, then later learns the initiator private key, can then decrypt the responder's public key.</p></li>
<li><p><strong>7.</strong> Not transmitted, but an active attacker who pretends to be the initator without the initiator's static private key, then later learns a candidate for the initiator private key, can then check whether the candidate is correct.</p></li>
<li><p><strong>8.</strong> Encrypted with forward secrecy to an authenticated party.</p></li>
</ul>
<p>Identity hiding properties for static public keys:</p>
<pre><code>           Initiator      Responder              
           ---------      ---------
Noise_N        -              3
Noise_K        5              5
Noise_X        4              3
Noise_NN       -              -
Noise_NK       -              3
Noise_NX       -              1
Noise_XN       2              -
Noise_XK       8              3
Noise_XX       8              1
Noise_XR       2              8
Noise_KN       7              -
Noise_KK       5              5
Noise_KX       7              6
Noise_IN       0              -
Noise_IK       4              3
Noise_IX       0              6</code></pre>
<h2 id="more-patterns">8.6. More patterns</h2>
<p>The patterns in the previous sections are useful examples which we are naming for convenience. Other valid patterns could be constructed, for example:</p>
<ul>
<li><p>It would be easy to modify <code>Noise_X</code> or <code>Noise_IK</code> to transmit the sender's static public key in cleartext instead of encrypted by changing <code>&quot;e, dhes,    s, dhss&quot;</code> to <code>&quot;e, s, dhes, dhss&quot;</code>. This would worsen identity hiding, so we're not bothering to name those patterns.</p></li>
<li><p>It would be easy to make <code>Noise_KK</code> or <code>Noise_IK</code> slightly more efficient by removing the <code>&quot;dhss&quot;</code>. This would worsen security properties for the initial exchange of handshake payloads, so we're not bothering to name those patterns.</p></li>
<li><p>In some patterns both initiator and responder have a static key pair, but <code>&quot;dhss&quot;</code> is not performed. This DH operation could be added to provide more resilience in case the ephemerals are generated by a bad RNG.</p></li>
<li><p>Pre-knowledge of ephemeral public keys is not demonstrated in any of the above patterns. This pre-knowledge could be used to implement a &quot;pre-key&quot; or &quot;semi-ephemeral key&quot; handshake, where the forward-secrecy and KCI-resistance of zero-RTT data is improved since the pre-distributed &quot;semi-ephemeral&quot; key can be changed more frequently than the responder's static key. These patterns might benefit from signatures, which are not yet included in Noise. These patterns also introduce new complexity around the lifetimes of semi-ephemeral key pairs, so are not discussed further here.</p></li>
</ul>
<h1 id="complex-protocols">9. Complex protocols</h1>
<p>A handshake pattern specifies a fixed sequence of messages. In some cases parties executing a handshake pattern may discover a need to send a different sequence of messages. Noise has two ways to handle this.</p>
<h2 id="dummy-static-public-keys">9.1. Dummy static public keys</h2>
<p>Consider a protocol where an initiator will authenticate itself if requested by the responder. This could be viewed as the initiator choosing between patterns like <code>Noise_NX</code> and <code>Noise_XX</code> based on some value inside the responder's first handshake payload.</p>
<p>Noise doesn't directly support this. Instead, this could be simulated by always executing <code>Noise_XX</code>. The initiator can simulate the <code>Noise_NX</code> case by sending a <strong>dummy static public key</strong> if authentication is not requested. The value of the dummy public key doesn't matter. For efficiency, the initiator can send a null public key value per <a href="#crypto-functions">Section 4</a> (e.g. an all-zeros <code>25519</code> value that is guaranteed to produce an all-zeros output).</p>
<p>This technique is simple, since it allows use of a single handshake pattern. It also doesn't reveal which option was chosen from message sizes. It could be extended to allow a <code>Noise_XX</code> pattern to support any permutation of authentications (initiator only, responder only, both, or none).</p>
<h2 id="handshake-re-initialization-and-noise-pipes">9.2. Handshake re-initialization and Noise Pipes</h2>
<p>Consider a protocol where the initiator can attempt zero-RTT encryption based on the responder's static public key. If the responder has changed their static public key, the parties will need to switch to a &quot;fallback&quot; handshake where the responder transmits the new static public key and the initiator resends the zero-RTT data.</p>
<p>This can be handled by both parties re-initalizing their <code>HandshakeState</code> and simply executing a different handshake. Public keys that were exchanged in the first handshake can be represented as pre-messages in the second handshake. If any important negotiation occurred in the first handshake, the first handshake's <code>h</code> variable should be provided as prologue to the second handshake.</p>
<p>By way of example, this section defines the <strong>Noise Pipe</strong> protocol. This protocol uses two patterns defined in the previous section: <code>Noise_XX</code> is used for an initial handshake if the parties haven't communicated before, after which the initiator can cache the responder's static public key. <code>Noise_IK</code> is used for a zero-RTT handshake.</p>
<p>If the responder fails to decrypt the first <code>Noise_IK</code> message (perhaps due to changing her static key), the responder will initiate a new <code>Noise_XXfallback</code> handshake identical to <code>Noise_XX</code> except re-using the ephemeral public key from the first <code>Noise_IK</code> message as a pre-message public key.</p>
<p>Below are the three patterns used for Noise Pipes:</p>
<pre><code>Noise_XX(s, rs):  
  -&gt; e
  &lt;- e, dhee, s, dhse  
  -&gt; s, dhse

Noise_IK(s, rs):                   
  &lt;- s                         
  ------
  -&gt; e, dhes, s, dhss          
  &lt;- e, dhee, dhes             
                                    
Noise_XXfallback(s, rs, re):                   
  &lt;- e
  ------
  -&gt; e, dhee, s, dhse
  &lt;- s, dhse</code></pre>
<p>Note that in the fallback case, the initiator and responder roles are switched: If Alice inititates a <code>Noise_IK</code> handshake with Bob, Bob might initiate a <code>Noise_XX_fallback</code> handshake.</p>
<p>There needs to be some way for the recipient of a message to distinguish whether it's the next message in the current handshake pattern, or requires re-initialization for a new pattern. For example, each handshake message could be preceded by a <code>type</code> byte (see <a href="#application-responsibilities">Section 12</a>). This byte is not part of the Noise message proper, but simply signals when re-initialization is needed:</p>
<ul>
<li><p>If <code>type == 0</code> in the initiator's first message then the initiator is performing a <code>Noise_XX</code> handshake.</p></li>
<li><p>If <code>type == 1</code> in the initiator's first message then the initiator is performing a <code>Noise_IK</code> handshake.</p></li>
<li><p>If <code>type == 1</code> in the responder's first <code>Noise_IK</code> response then the responder failed to authenticate the initiator's <code>Noise_IK</code> message and is performing a <code>Noise_XXfallback</code> handshake, using the initiator's ephemeral public key as a pre-message.</p></li>
<li><p>In all other cases, <code>type</code> will be 0.</p></li>
</ul>
<h1 id="dh-functions-cipher-functions-and-hash-functions">10. DH functions, cipher functions, and hash functions</h1>
<h2 id="the-25519-dh-functions">10.1. The <code>25519</code> DH functions</h2>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Returns a new Curve25519 keypair.</p></li>
<li><p><strong><code>DH(privkey, pubkey)</code></strong>: Executes the Curve25519 DH function (aka &quot;X25519&quot; in <a href="https://www.ietf.org/rfc/rfc7748.txt">RFC 7748</a>). The null public key value is all zeros, which will always produce an output of all zeros. Other invalid public key values will also produce an output of all zeros.</p></li>
<li><p><strong><code>DHLEN</code></strong> = 32</p></li>
</ul>
<h2 id="the-448-dh-functions">10.2. The <code>448</code> DH functions</h2>
<ul>
<li><p><strong><code>GENERATE_KEYPAIR()</code></strong>: Returns a new Curve448 keypair.</p></li>
<li><p><strong><code>DH(privkey, pubkey)</code></strong>: Executes the Curve448 DH function (aka &quot;X448&quot; in <a href="https://www.ietf.org/rfc/rfc7748.txt">RFC 7748</a>). The null public key value is all zeros, which will always produce an output of all zeros. Other invalid public key values will also produce an output of all zeros.</p></li>
<li><p><strong><code>DHLEN</code></strong> = 56</p></li>
</ul>
<h2 id="the-chachapoly-cipher-functions">10.3. The <code>ChaChaPoly</code> cipher functions</h2>
<ul>
<li><strong><code>ENCRYPT(k, n, ad, plaintext)</code> / <code>DECRYPT(k, n, ad, ciphertext)</code></strong>: <code>AEAD_CHACHA20_POLY1305</code> from <a href="https://www.ietf.org/rfc/rfc7539.txt">RFC 7539</a>. The 96-bit nonce is formed by encoding 32 bits of zeros followed by little-endian encoding of <code>n</code>. (Earlier implementations of ChaCha20 used a 64-bit nonce, in which case it's compatible to encode <code>n</code> directly into the ChaCha20 nonce without the 32-bit zero prefix).</li>
</ul>
<h2 id="the-aesgcm-cipher-functions">10.4. The <code>AESGCM</code> cipher functions</h2>
<ul>
<li><strong><code>ENCRYPT(k, n, ad, plaintext)</code> / <code>DECRYPT(k, n, ad, ciphertext)</code></strong>: AES256-GCM from <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">NIST SP 800-38D</a> with 128-bit tags. The 96-bit nonce is formed by encoding 32 bits of zeros followed by big-endian encoding of <code>n</code>.</li>
</ul>
<h2 id="the-sha256-hash-function">10.5. The <code>SHA256</code> hash function</h2>
<ul>
<li><p><strong><code>HASH(input)</code></strong>: <code>SHA2-256(input)</code></p></li>
<li><p><strong><code>HASHLEN</code></strong> = 32</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = 64</p></li>
</ul>
<h2 id="the-sha512-hash-function">10.6. The <code>SHA512</code> hash function</h2>
<ul>
<li><p><strong><code>HASH(input)</code></strong>: <code>SHA2-512(input)</code></p></li>
<li><p><strong><code>HASHLEN</code></strong> = 64</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = 128</p></li>
</ul>
<h2 id="the-blake2s-hash-function">10.7. The <code>BLAKE2s</code> hash function</h2>
<ul>
<li><p><strong><code>HASH(input)</code></strong>: <code>BLAKE2s(input)</code> with digest length 32.</p></li>
<li><p><strong><code>HASHLEN</code></strong> = 32</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = 64</p></li>
</ul>
<h2 id="the-blake2b-hash-function">10.8. The <code>BLAKE2b</code> hash function</h2>
<ul>
<li><p><strong><code>HASH(input)</code></strong>: <code>BLAKE2b(input)</code> with digest length 64.</p></li>
<li><p><strong><code>HASHLEN</code></strong> = 64</p></li>
<li><p><strong><code>BLOCKLEN</code></strong> = 128</p></li>
</ul>
<h1 id="protocol-names">11. Protocol names</h1>
<p>To produce a <strong>Noise protocol name</strong> for <code>Initialize()</code> you concatenate the names for the handshake pattern, the DH functions, the cipher functions, and the hash function. For example:</p>
<ul>
<li><p><code>Noise_XX_25519_AESGCM_SHA256</code></p></li>
<li><p><code>Noise_N_25519_ChaChaPoly_BLAKE2s</code></p></li>
<li><p><code>Noise_XXfallback_448_AESGCM_SHA512</code></p></li>
<li><p><code>Noise_IK_448_ChaChaPoly_BLAKE2b</code></p></li>
</ul>
<p>If a pre-shared symmetric key is in use, then the prefix <code>NoisePSK_</code> is used instead of <code>Noise_</code>:</p>
<ul>
<li><p><code>NoisePSK_XX_25519_AESGCM_SHA256</code></p></li>
<li><p><code>NoisePSK_N_25519_ChaChaPoly_BLAKE2s</code></p></li>
<li><p><code>NoisePSK_XXfallback_448_AESGCM_SHA512</code></p></li>
<li><p><code>NoisePSK_IK_448_ChaChaPoly_BLAKE2b</code></p></li>
</ul>
<h1 id="application-responsibilities">12. Application responsibilities</h1>
<p>An application built on Noise must consider several issues:</p>
<ul>
<li><p><strong>Choosing crypto functions</strong>: The <code>25519</code> DH functions are recommended for most uses, along with either <code>AESGCM_SHA256</code> or <code>ChaChaPoly_BLAKE2s</code>. For an extreme security margin, you could use the <code>448</code> DH functions with either <code>AESGCM_SHA512</code> or <code>ChaChaPoly_BLAKE2b</code>.</p></li>
<li><p><strong>Extensibility</strong>: Applications are recommended to use an extensible data format for the payloads of all messages (e.g. JSON, Protocol Buffers). This ensures that fields can be added in the future which are ignored by older implementations.</p></li>
<li><p><strong>Padding</strong>: Applications are recommended to use a data format for the payloads of all encrypted messages that allows padding. This allows implementations to avoid leaking information about message sizes. Using an extensible data format, per the previous bullet, will typically suffice.</p></li>
<li><p><strong>Termination</strong>: Applications must consider that a sequence of Noise transport messages could be truncated by an attacker. Applications should include explicit length fields or termination signals inside of transport payloads to signal the end of a stream of transport messages.</p></li>
<li><p><strong>Length fields</strong>: Applications must handle any framing or additional length fields for Noise messages, considering that a Noise message may be up to 65535 bytes in length. If an explicit length field is needed, applications are recommended to add a 16-bit big-endian length field prior to each message.</p></li>
<li><p><strong>Type fields</strong>: Applications are recommended to include a single-byte type field prior to each Noise handshake message (and prior to the length field, if one is included). Applications would reject messages with unknown type. This allows extending the handshake with handshake re-initialization or other alternative messages in the future.</p></li>
</ul>
<h1 id="security-considerations">13. Security considerations</h1>
<p>This section collects various security considerations:</p>
<ul>
<li><p><strong>Termination</strong>: Preventing attackers from truncating a stream of transport messages is an application responsibility. See previous section.</p></li>
<li><p><strong>Data volumes</strong>: The <code>AESGCM</code> cipher functions suffer a gradual reduction in security as the volume of data encrypted under a single key increases. Due to this, parties should not send more than 2^56 bytes (roughly 72 petabytes) encrypted by a single key. If sending such large volumes of data is a possibility, different cipher functions should be chosen.</p></li>
<li><p><strong>Rollback</strong>: If parties decide on a Noise protocol based on some previous negotiation that is not included as prologue, then a rollback attack might be possible. This is a particular risk with handshake re-initialization, and requires careful attention if a Noise handshake is preceded by communication between the parties.</p></li>
<li><p><strong>Incrementing nonces</strong>: Reusing a nonce value for <code>n</code> with the same key <code>k</code> for encryption would be catastrophic. Implementations must carefully follow the rules for nonces. Nonces are not allowed to wrap back to zero due to integer overflow. This means parties are not allowed to send more than 2^64 transport messages.</p></li>
<li><p><strong>Fresh ephemerals</strong>: Every party in a Noise protocol should send a new ephemeral public key and perform a DH with it prior to sending any encrypted data. Otherwise replay of a handshake message could trigger catastrophic key reuse. This is one rationale behind the patterns in <a href="#handshake-patterns">Section 8</a>, and the validity rules in <a href="#pattern-validity">Section 8.1</a>. It's also the reason why one-way handshakes only allow transport messages from the sender, not the recipient.</p></li>
<li><p><strong>Protocol names</strong>: The protocol name used with <code>Initialize()</code> must uniquely identify the combination of handshake pattern and crypto functions for every key it's used with (whether ephemeral key pair, static key pair, or PSK). If the same secret key was reused with the same protocol name but a different set of cryptographic operations then bad interactions could occur.</p></li>
<li><p><strong>Pre-shared symmetric keys</strong>: Pre-shared symmetric keys should be secret values with 256 bits of entropy (or more).</p></li>
<li><p><strong>Channel binding</strong>: Depending on the DH functions, it might be possible for a malicious party to engage in multiple sessions that derive the same shared secret key (e.g. if setting her public keys to invalid values causes DH outputs of zero, as is the case for the <code>25519</code> and <code>448</code> DH functions). If a higher-level protocol wants a unique &quot;channel binding&quot; value for referring to a Noise session it should use the value of <code>h</code> after the final handshake message, not <code>ck</code>.</p></li>
<li><p><strong>Implementation fingerprinting</strong>: If this protocol is used in settings with anonymous parties, care should be taken that implementations behave identically in all cases. This may require mandating exact behavior for handling of invalid DH public keys.</p></li>
</ul>
<h1 id="rationale">14. Rationale</h1>
<p>This section collects various design rationale:</p>
<p>Nonces are 64 bits in length because:</p>
<ul>
<li>Some ciphers (e.g. Salsa20) only have 64 bit nonces.</li>
<li>64 bit nonces were used in the initial specification and implementations of ChaCha20, so Noise nonces can be used with these implementations.</li>
<li>64 bits makes it easy for the entire nonce to be treated as an integer and incremented.</li>
<li>96 bits nonces (e.g. in RFC 7539) are a confusing size where it's unclear if random nonces are acceptable.</li>
</ul>
<p>The recommended hash function families are SHA2 and BLAKE2 because:</p>
<ul>
<li>SHA2 is widely available.</li>
<li>SHA2 is often used alongside AES.</li>
<li>BLAKE2 is similar to ChaCha20.</li>
</ul>
<p>Hash output lengths of 256 bits are supported because:</p>
<ul>
<li>SHA2-256 and BLAKE2s have sufficient collision-resistance at the 128-bit security level.</li>
<li>SHA2-256 and BLAKE2s require less RAM, and less calculation when processing smaller inputs (due to smaller block size), then their larger brethren (SHA2-512 and BLAKE2b).</li>
<li>SHA2-256 and BLAKE2s are faster on 32-bit processors than their larger brethren.</li>
</ul>
<p>Cipher keys are 256 bits because:</p>
<ul>
<li>256 bits is a conservative length for cipher keys when considering cryptanalytic safety margins, time/memory tradeoffs, multi-key attacks, and quantum attacks.</li>
</ul>
<p>The authentication tag is 128 bits because:</p>
<ul>
<li>Some algorithms (e.g. GCM) lose more security than an ideal MAC when truncated.</li>
<li>Noise may be used in a wide variety of contexts, including where attackers can receive rapid feedback on whether MAC guesses are correct.</li>
<li>A single fixed length is simpler than supporting variable-length tags.</li>
</ul>
<p>The GCM security limit is 2^56 bytes because:</p>
<ul>
<li>This is 2^52 AES blocks (each block is 16 bytes). The limit is based on the risk of birthday collisions being used to rule out plaintext guesses. The probability an attacker could rule out a random guess on a 2^56 byte plaintext is less than 1 in 1 million (roughly (2^52 * 2^52) / 2^128).</li>
</ul>
<p>Big-endian is preferred because:</p>
<ul>
<li>Any Noise length fields are likely to be handled by parsing code where big-endian &quot;network byte order&quot; is traditional.</li>
<li>Some ciphers use big-endian internally (e.g. GCM, SHA2).</li>
<li>While it's true that Curve25519, Curve448, and ChaCha20/Poly1305 use little-endian, these will likely be handled by specialized libraries, so there's not a strong argument for aligning with them.</li>
</ul>
<p>The <code>MixKey()</code> design uses <code>HKDF</code> because:</p>
<ul>
<li>HKDF is a conservative and widely used design.</li>
</ul>
<p><code>MixHash()</code> is used instead of <code>MixKey()</code> because:</p>
<ul>
<li><code>MixHash()</code> is more efficient than <code>MixKey()</code>.</li>
<li><code>MixHash()</code> avoids any IPR concerns regarding mixing identity data into session keys (see KEA+).</li>
<li><code>MixHash()</code> produces a non-secret <code>h</code> value that might be useful to higher-level protocols, e.g. for channel-binding.</li>
</ul>
<h1 id="ipr">15. IPR</h1>
<p>The Noise specification (this document) is hereby placed in the public domain.</p>
<h1 id="acknowledgements">16. Acknowledgements</h1>
<p>Noise is inspired by the NaCl and CurveCP protocols from Dan Bernstein et al., and also by HOMQV and SIGMA from Hugo Krawzcyk.</p>
<p>Feedback on the spec came from: Moxie Marlinspike, Jason Donenfeld, Tiffany Bennett, Jonathan Rudenberg, Stephen Touset, and Tony Arcieri.</p>
<p>Thanks to Tom Ritter and Karthikeyan Bhargavan for editorial feedback.</p>
<p>Moxie Marlinspike, Christian Winnerlein, and Hugo Krawzcyk provided feedback on key derivation.</p>
<p>Jeremy Clark, Thomas Ristenpart, and Joe Bonneau gave feedback on much earlier versions.</p>
</body>
</html>
